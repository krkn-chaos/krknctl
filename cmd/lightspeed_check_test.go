// Generated by Claude Sonnet 4
package cmd

import (
	"context"
	"io"
	"os"
	"testing"

	"github.com/krkn-chaos/krknctl/pkg/config"
	"github.com/krkn-chaos/krknctl/pkg/gpucheck"
	"github.com/krkn-chaos/krknctl/pkg/provider/factory"
	"github.com/krkn-chaos/krknctl/pkg/provider/models"
	"github.com/krkn-chaos/krknctl/pkg/scenarioorchestrator"
	orchestratormodels "github.com/krkn-chaos/krknctl/pkg/scenarioorchestrator/models"
	"github.com/spf13/cobra"
	"github.com/stretchr/testify/assert"
)

// Test helper functions
func getTestConfig(t *testing.T) config.Config {
	config, err := config.LoadConfig()
	assert.NoError(t, err)
	return config
}

func getTestProviderFactory(t *testing.T) *factory.ProviderFactory {
	return &factory.ProviderFactory{}
}

func getTestOrchestrator(t *testing.T) scenarioorchestrator.ScenarioOrchestrator {
	// Create a mock orchestrator for testing
	return &MockScenarioOrchestrator{}
}

// MockScenarioOrchestrator for testing
type MockScenarioOrchestrator struct{}

func (m *MockScenarioOrchestrator) Connect(containerRuntimeURI string) (context.Context, error) {
	return context.Background(), nil
}

func (m *MockScenarioOrchestrator) Run(image, containerName string, env map[string]string, cache bool, volumeMounts map[string]string, devices *map[string]string, commChan *chan *string, ctx context.Context, registry *models.RegistryV2, portMappings *map[string]string) (*string, error) {
	id := "mock-container-id"
	return &id, nil
}

func (m *MockScenarioOrchestrator) RunAttached(image string, containerName string, env map[string]string, cache bool, volumeMounts map[string]string, devices *map[string]string, stdout io.Writer, stderr io.Writer, commChan *chan *string, ctx context.Context, registry *models.RegistryV2) (*string, error) {
	id := "mock-container-id"
	return &id, nil
}

func (m *MockScenarioOrchestrator) GetContainerRuntime() orchestratormodels.ContainerRuntime {
	return orchestratormodels.Podman
}

func (m *MockScenarioOrchestrator) PrintContainerRuntime() {}

func (m *MockScenarioOrchestrator) GetConfig() config.Config {
	config, _ := config.LoadConfig()
	return config
}

func (m *MockScenarioOrchestrator) GetContainerRuntimeSocket(userID *int) (*string, error) {
	socket := "unix:///tmp/podman.sock"
	return &socket, nil
}

func (m *MockScenarioOrchestrator) Kill(containerID *string, ctx context.Context) error {
	return nil
}

func (m *MockScenarioOrchestrator) CleanContainers(ctx context.Context) (*int, error) {
	count := 0
	return &count, nil
}

// Implement other required interface methods as no-ops
func (m *MockScenarioOrchestrator) RunGraph(scenarios orchestratormodels.ScenarioSet, resolvedGraph orchestratormodels.ResolvedGraph, extraEnv map[string]string, extraVolumeMounts map[string]string, cache bool, commChannel chan *orchestratormodels.GraphCommChannel, registry *models.RegistryV2, userID *int) {
}
func (m *MockScenarioOrchestrator) AttachWait(containerID *string, stdout io.Writer, stderr io.Writer, ctx context.Context) (*bool, error) {
	return nil, nil
}
func (m *MockScenarioOrchestrator) Attach(containerID *string, signalChannel chan os.Signal, stdout io.Writer, stderr io.Writer, ctx context.Context) (bool, error) {
	return false, nil
}
func (m *MockScenarioOrchestrator) ListRunningContainers(ctx context.Context) (*map[int64]orchestratormodels.Container, error) {
	return nil, nil
}
func (m *MockScenarioOrchestrator) ListRunningScenarios(ctx context.Context) (*[]orchestratormodels.ScenarioContainer, error) {
	return nil, nil
}
func (m *MockScenarioOrchestrator) InspectScenario(container orchestratormodels.Container, ctx context.Context) (*orchestratormodels.ScenarioContainer, error) {
	return nil, nil
}
func (m *MockScenarioOrchestrator) ResolveContainerName(containerName string, ctx context.Context) (*string, error) {
	return nil, nil
}

func TestNewLightspeedCommand(t *testing.T) {
	cmd := NewLightspeedCommand()

	assert.NotNil(t, cmd)
	assert.Equal(t, "lightspeed", cmd.Use)
	assert.Contains(t, cmd.Short, "GPU and acceleration")
	assert.Contains(t, cmd.Long, "GPU and acceleration related utilities")

	// Test that GPU auto-detection is enabled (no manual GPU flags needed)
	assert.NotNil(t, cmd.PersistentFlags().Lookup("offline"))
	// Manual GPU flags should not exist (using auto-detection now)
	assert.Nil(t, cmd.PersistentFlags().Lookup("nvidia"))
	assert.Nil(t, cmd.PersistentFlags().Lookup("apple-silicon"))
	assert.Nil(t, cmd.PersistentFlags().Lookup("amd"))
	assert.Nil(t, cmd.PersistentFlags().Lookup("intel"))
}

func TestNewLightspeedCheckCommand(t *testing.T) {
	config := getTestConfig(t)
	providerFactory := getTestProviderFactory(t)
	orchestrator := getTestOrchestrator(t)

	cmd := NewLightspeedCheckCommand(providerFactory, &orchestrator, config)

	assert.NotNil(t, cmd)
	assert.Equal(t, "check", cmd.Use)
	assert.Contains(t, cmd.Short, "Check GPU support")
	assert.Contains(t, cmd.Long, "Check whether the container runtime")
	assert.NotNil(t, cmd.Args)
	assert.NotNil(t, cmd.RunE)
}

func TestBuildLightspeedRegistryFromFlags_NoPrivateRegistry(t *testing.T) {
	cmd := &cobra.Command{}
	config := getTestConfig(t)

	// Add all the required flags but don't set private-registry
	cmd.Flags().String("private-registry", "", "")
	cmd.Flags().String("private-registry-lightspeed", "", "")
	cmd.Flags().String("private-registry-username", "", "")
	cmd.Flags().String("private-registry-password", "", "")
	cmd.Flags().String("private-registry-token", "", "")
	cmd.Flags().Bool("private-registry-insecure", false, "")
	cmd.Flags().Bool("private-registry-skip-tls", false, "")

	registry, err := buildLightspeedRegistryFromFlags(cmd, config)

	assert.NoError(t, err)
	assert.Nil(t, registry)
}

func TestGPUAutoDetection(t *testing.T) {
	config := getTestConfig(t)
	detector := gpucheck.NewPlatformGPUDetector(config)

	// Test GPU detection types
	ctx := context.Background()
	
	// Test with --no-gpu flag
	gpuType := detector.DetectGPUAcceleration(ctx, true)
	assert.Equal(t, gpucheck.GPUAccelerationGeneric, gpuType)
	
	// Test description generation
	description := detector.GetGPUDescription(gpucheck.GPUAccelerationAppleSilicon)
	assert.Contains(t, description, "Apple Silicon")
	
	description = detector.GetGPUDescription(gpucheck.GPUAccelerationNVIDIA)
	assert.Contains(t, description, "NVIDIA")
	
	description = detector.GetGPUDescription(gpucheck.GPUAccelerationGeneric)
	assert.Contains(t, description, "CPU-only")
}

// Test command creation and basic structure
func TestLightspeedCommands_Structure(t *testing.T) {
	config := getTestConfig(t)
	providerFactory := getTestProviderFactory(t)
	orchestrator := getTestOrchestrator(t)

	// Test lightspeed command creation
	lightspeedCmd := NewLightspeedCommand()
	assert.NotNil(t, lightspeedCmd)
	assert.Equal(t, "lightspeed", lightspeedCmd.Use)

	// Test check command creation
	checkCmd := NewLightspeedCheckCommand(providerFactory, &orchestrator, config)
	assert.NotNil(t, checkCmd)
	assert.Equal(t, "check", checkCmd.Use)
	assert.NotNil(t, checkCmd.RunE)

	// Add check command to lightspeed
	lightspeedCmd.AddCommand(checkCmd)
	assert.Equal(t, 1, len(lightspeedCmd.Commands()))
}
