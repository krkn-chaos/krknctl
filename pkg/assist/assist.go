// Generated by Claude Code
// RAG model deployment functions for krknctl assist

package assist

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/briandowns/spinner"
	"github.com/fatih/color"
	"github.com/krkn-chaos/krknctl/pkg/config"
	"github.com/krkn-chaos/krknctl/pkg/forms"
	"github.com/krkn-chaos/krknctl/pkg/provider"
	"github.com/krkn-chaos/krknctl/pkg/provider/models"
	"github.com/krkn-chaos/krknctl/pkg/scenarioorchestrator"
	"github.com/krkn-chaos/krknctl/pkg/scenarioorchestrator/utils"
	"github.com/krkn-chaos/krknctl/pkg/text"
	"github.com/krkn-chaos/krknctl/pkg/typing"
	"github.com/manifoldco/promptui"
	"github.com/rodaine/table"
)

// ParsedField represents a parsed field with its value and whether it's secret
type ParsedField struct {
	value  string
	secret bool
}

// DeployAssistModelWithGPUType deploys the RAG model container using the new GPU detection system
func DeployAssistModelWithGPUType(ctx context.Context, gpuType GPUAcceleration, orchestrator scenarioorchestrator.ScenarioOrchestrator, config config.Config, registry *models.RegistryV2, detector GPUDetector, pullSpinner *spinner.Spinner) (*RAGDeploymentResult, error) {
	// Get the appropriate assist image for the detected GPU type
	ragImageURI, err := detector.GetAssistImageURI(gpuType)
	if err != nil {
		return nil, fmt.Errorf("failed to get assist image URI: %w", err)
	}

	// Generate unique container name using config
	containerName := fmt.Sprintf("%s-%d", config.RAGContainerPrefix, time.Now().Unix())

	// Set up environment variables
	env := map[string]string{}

	// Add GPU-specific environment variables for optimal performance
	switch gpuType {
	case GPUAccelerationNVIDIA:
		env["CUDA_VISIBLE_DEVICES"] = "0"
		env["TORCH_USE_CUDA_DSA"] = "1"
		env["PYTORCH_CUDA_ALLOC_CONF"] = "max_split_size_mb:128"
	case GPUAccelerationAppleSilicon:
		env["PYTORCH_ENABLE_MPS_FALLBACK"] = "1"
		env["PYTORCH_MPS_HIGH_WATERMARK_RATIO"] = "0.0"
	case GPUAccelerationGeneric:
		env["OMP_NUM_THREADS"] = "4"
		env["MKL_NUM_THREADS"] = "4"
	}

	// Get device mounts from detector
	devices := detector.GetDeviceMounts(gpuType)

	// Set up port mapping using config
	hostPort := config.RAGServicePort      // Host port (e.g., "8080")
	containerPort := config.RAGServicePort // Container port (e.g., "8080")
	portMappings := &map[string]string{
		hostPort: containerPort, // host port -> container port
	}

	// Use provided spinner for pull progress
	if pullSpinner != nil {
		pullSpinner.Suffix = " pulling RAG model image..."
		pullSpinner.Start()
	}

	// Create communication channel for pull progress updates
	commChan := make(chan *string)
	go func() {
		for msg := range commChan {
			if pullSpinner != nil {
				pullSpinner.Suffix = *msg
			}
		}
		if pullSpinner != nil {
			pullSpinner.Stop()
		}
	}()

	// Run the RAG container in detached mode
	containerID, err := orchestrator.Run(ragImageURI, containerName, env, false, nil, &devices,
		&commChan, ctx, registry, portMappings)

	// The orchestrator closes the channel automatically, so we don't need to close it manually
	if err != nil {
		return nil, fmt.Errorf("failed to run RAG container: %w", err)
	}
	fmt.Printf("üöÄ RAG container started: %s\n", *containerID)
	fmt.Printf("üì° Port mapping: %s:%s -> container:%s\n", config.RAGHost, hostPort, config.RAGServicePort)

	return &RAGDeploymentResult{
		ContainerID: *containerID,
		HostPort:    hostPort,
	}, nil
}

// PerformAssistHealthCheck performs health checking with timeout and cleanup on failure
func PerformAssistHealthCheck(containerID string, hostPort string, orchestrator scenarioorchestrator.ScenarioOrchestrator, ctx context.Context, config config.Config) (bool, error) {
	// Health URL is constructed from trusted config values and validated port
	healthURL := fmt.Sprintf("http://%s:%s%s", config.RAGHost, hostPort, config.RAGHealthEndpoint)
	maxRetries := config.RAGHealthMaxRetries
	retryInterval := time.Duration(config.RAGHealthRetryIntervalSeconds) * time.Second

	fmt.Printf("ü©∫ health checking assist service at %s...\n", healthURL)

	for i := 0; i < maxRetries; i++ {
		// Check if container is still running
		containers, err := orchestrator.ListRunningContainers(ctx)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è  warning: failed to list containers: %v\n", err)
		} else {
			containerFound := false
			if containers != nil {
				for _, container := range *containers {
					if container.ID == containerID {
						containerFound = true
						break
					}
				}
			}
			if !containerFound {
				return false, fmt.Errorf("container %s is no longer running", containerID)
			}
		}

		// Perform health check - URL is safe as it's constructed from config
		// #nosec G107 - URL constructed from trusted configuration
		resp, err := http.Get(healthURL)
		if err == nil && resp.StatusCode == 200 {
			var health HealthResponse
			if err := json.NewDecoder(resp.Body).Decode(&health); err == nil {
				if closeErr := resp.Body.Close(); closeErr != nil {
					fmt.Printf("‚ö†Ô∏è  warning: failed to close response body: %v\n", closeErr)
				}
				if health.Status == "healthy" {
					fmt.Printf("‚úÖ service healthy: %s with %d documents indexed\n", health.Model,
						health.DocumentsIndexed)
					return true, nil
				}
			}
			if closeErr := resp.Body.Close(); closeErr != nil {
				fmt.Printf("‚ö†Ô∏è  warning: failed to close response body: %v\n", closeErr)
			}
		}

		if i < maxRetries-1 {
			fmt.Printf("‚è≥ waiting for service to become ready... (%d/%d)\n", i+1, maxRetries)
			time.Sleep(retryInterval)
		}
	}

	// Health check failed, clean up the container
	timeoutMinutes := (maxRetries * config.RAGHealthRetryIntervalSeconds) / 60
	fmt.Printf("‚ùå health check timed out after %d minutes, cleaning up container...\n",
		timeoutMinutes)
	if err := orchestrator.Kill(&containerID, ctx); err != nil {
		fmt.Printf("‚ö†Ô∏è  warning: failed to clean up container %s: %v\n", containerID, err)
	}

	return false, fmt.Errorf("service did not become healthy within timeout")
}

// StartInteractivePrompt starts an interactive chat session with the Lightspeed service
func StartInteractivePrompt(containerID string, hostPort string, orchestrator scenarioorchestrator.ScenarioOrchestrator, ctx context.Context, config config.Config, thinkingSpinner *spinner.Spinner, scenarioProvider provider.ScenarioDataProvider) error {
	scanner := bufio.NewScanner(os.Stdin)

	// Set up signal handling for Ctrl+C
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM)

	// Handle Ctrl+C in a goroutine
	go func() {
		<-signalChan
		fmt.Println("\n\nüõë interrupted! Cleaning up assist service...")
		if err := orchestrator.Kill(&containerID, ctx); err != nil {
			fmt.Printf("‚ö†Ô∏è  warning: failed to stop assist container: %v\n", err)
		} else {
			fmt.Println("‚úÖ assist service stopped successfully")
		}
		os.Exit(0)
	}()

	fmt.Printf("‚ö° assist AI Assistant ready! Ask me about krknctl commands or chaos" +
		" engineering:\n")
	fmt.Printf("üìç service available at: http://%s:%s\n", config.RAGHost, hostPort)
	fmt.Printf("üí° try asking: 'How do I run a pod deletion scenario?'\n")
	fmt.Printf("üö™ type 'exit', 'quit', or press Ctrl+C to stop.\n\n")

	for {
		fmt.Print("> ")
		if !scanner.Scan() {
			break
		}

		query := strings.TrimSpace(scanner.Text())
		if query == "" {
			continue
		}

		if strings.ToLower(query) == "exit" || strings.ToLower(query) == "quit" {
			fmt.Println("üëã Goodbye!")
			break
		}

		// Send query to Lightspeed service with spinner and timing
		if thinkingSpinner != nil {
			thinkingSpinner.Suffix = " thinking..."
			thinkingSpinner.Start()
		}

		startTime := time.Now()
		response, err := queryAssistService(hostPort, query, config)
		elapsed := time.Since(startTime)

		if thinkingSpinner != nil {
			thinkingSpinner.Stop()
		}

		// Display response time
		fmt.Printf("‚è±Ô∏è  Response time: %.2fs\n", elapsed.Seconds())

		if err != nil {
			fmt.Printf("‚ùå error: %v\n", err)
			fmt.Printf("üí° tip: Make sure the service is fully initialized. " +
				"Large models may take a few minutes.\n")
			continue
		}

		// Display response with beautiful formatting
		if len(response.Choices) > 0 {
			err := PrintAssistAnswer(response.Choices[0].Message.Content)
			if err != nil {
				return err
			}
		} else {
			fmt.Printf("\nüö´ no response received\n")
		}

		// If a scenario was detected, show scenario details
		if response.ScenarioName != nil && *response.ScenarioName != "" {
			fmt.Printf("\nüìã fetching details for scenario: %s\n", *response.ScenarioName)

			scenarioDetail, err := scenarioProvider.GetScenarioDetail(*response.ScenarioName, nil)
			if err != nil {
				fmt.Printf("‚ö†Ô∏è  could not fetch scenario details: %v\n", err)
			} else if scenarioDetail != nil {
				printScenarioDetail(scenarioDetail)

				// Ask if user wants to run the scenario
				runPrompt := promptui.Prompt{
					Label:     "Do you want to run the scenario?",
					IsConfirm: true,
					Default:   "n",
				}

				if _, err := runPrompt.Run(); err == nil {
					// User confirmed, get global environment and show the form
					fmt.Printf("\nüîß configuring scenario parameters...\n")

					globalDetail, err := scenarioProvider.GetGlobalEnvironment(nil, *response.ScenarioName)
					if err != nil {
						fmt.Printf("‚ùå error getting global environment: %v\n", err)
						continue
					}

					form := forms.NewForm(scenarioDetail.Fields, nil)

					// Add global fields to GlobalItems array
					for _, field := range globalDetail.Fields {
						var predefinedValue *string
						item := forms.FormPromptItem{
							Field:           &field,
							PredefinedValue: predefinedValue,
						}
						form.GlobalItems = append(form.GlobalItems, item)
					}

					allFields := append(globalDetail.Fields, scenarioDetail.Fields...)

					// Run the form to collect input
					formResult, err := form.Run()
					if err != nil {
						fmt.Printf("‚ùå error collecting form data: %v\n", err)
						continue
					}

					// Show form summary
					formResult.PrintSummary(allFields)

					// Execute the scenario with form data
					err = executeScenario(*response.ScenarioName, scenarioDetail, formResult, orchestrator, ctx, config, scenarioProvider)
					if err != nil {
						fmt.Printf("‚ùå error executing scenario: %v\n", err)
					}
				}
			}
		}

		fmt.Println()
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading input: %w", err)
	}

	// Clean up: stop the container
	fmt.Println("\nüßπ cleaning up assist service...")
	if err := orchestrator.Kill(&containerID, ctx); err != nil {
		fmt.Printf("‚ö†Ô∏è  warning: failed to stop assist container: %v\n", err)
	} else {
		fmt.Println("‚úÖ assist service stopped successfully")
	}

	return nil
}

// queryAssistService sends a query to the assist service and returns the response
func queryAssistService(hostPort string, query string, config config.Config) (*QueryResponse, error) {
	// Query URL is constructed from trusted config values and validated port
	url := fmt.Sprintf("http://%s:%s%s", config.RAGHost, hostPort, config.RAGQueryEndpoint)

	requestBody := QueryRequest{
		Model: "llama",
		Messages: []ChatMessage{
			{
				Role:    "user",
				Content: query,
			},
		},
		Temperature: 0.7,
		MaxTokens:   512,
		Stream:      false,
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// #nosec G107 - URL constructed from trusted configuration
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("service returned error %d: %s", resp.StatusCode, string(body))
	}

	var response QueryResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &response, nil
}

// printScenarioDetail prints scenario details in the same format as cmd/describe.go
func printScenarioDetail(scenarioDetail *models.ScenarioDetail) {
	fmt.Print("\n")
	_, _ = color.New(color.FgGreen, color.Underline).Println(scenarioDetail.Title)
	justifiedText := text.Justify(scenarioDetail.Description, 65)
	for _, line := range justifiedText {
		fmt.Println(line)
	}
	fmt.Print("\n")
	argumentTable := newArgumentTable(scenarioDetail.Fields)
	argumentTable.Print()
	fmt.Print("\n")
}

// newArgumentTable creates argument table in same style as cmd/tables.go
func newArgumentTable(inputFields []typing.InputField) table.Table {
	var headerFmt = color.New(color.FgGreen, color.Underline).SprintfFunc()
	var columnFmt = color.New(color.FgYellow).SprintfFunc()

	tbl := table.New("Name", "Type", "Description", "Required", "Default")
	tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(columnFmt)
	for _, inputField := range inputFields {
		defaultValue := ""
		if inputField.Default != nil {
			defaultValue = *inputField.Default
		}
		tbl.AddRow(fmt.Sprintf("--%s", *inputField.Name), inputField.Type.String(), *inputField.ShortDescription, inputField.Required, defaultValue)
	}
	return tbl
}

// PrintAssistAnswer prints Lightspeed AI response with beautiful formatting
func PrintAssistAnswer(content string) error {
	fmt.Print("\n")
	// Use cyan color with underline for Lightspeed title (different from green scenario titles)
	_, _ = color.New(color.FgCyan, color.Underline, color.Bold).Println("‚ö° AI assist Response")
	fmt.Print("\n")

	// Justify the text content similar to scenario descriptions
	justifiedText := text.Justify(content, 75) // Slightly wider than scenario descriptions (65)

	// Use bright white color for the content for better readability
	contentColor := color.New(color.FgHiWhite)
	for _, line := range justifiedText {
		_, err := contentColor.Println(line)
		if err != nil {
			return err
		}
	}
	fmt.Print("\n")
	return nil
}

// NewEnvironmentTable creates a table to display environment variables
func NewEnvironmentTable(env map[string]ParsedField, config config.Config) table.Table {
	var headerFmt = color.New(color.FgGreen, color.Underline).SprintfFunc()
	var columnFmt = color.New(color.FgYellow).SprintfFunc()

	tbl := table.New("Environment Value", "Value")
	tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(columnFmt)
	for k, v := range env {
		value := reduceString(v.value, config)
		if v.secret {
			tbl.AddRow(k, utils.MaskString(value))
		} else {
			tbl.AddRow(k, value)
		}
	}
	return tbl
}

// reduceString truncates a string if it's longer than the configured maximum
func reduceString(value string, config config.Config) string {
	if len(value) > config.TableFieldMaxLength {
		return fmt.Sprintf("%s...(%d bytes more)", value[0:config.TableFieldMaxLength], len(value)-config.TableFieldMaxLength)
	}
	return value
}

// executeScenario executes a chaos scenario with the provided form data using attached mode
func executeScenario(scenarioName string, scenarioDetail *models.ScenarioDetail, formResult *forms.FormResult, orchestrator scenarioorchestrator.ScenarioOrchestrator, ctx context.Context, config config.Config, scenarioProvider provider.ScenarioDataProvider) error {
	fmt.Printf("\nüöÄ executing scenario: %s\n", scenarioName)

	// Get global environment details
	globalDetail, err := scenarioProvider.GetGlobalEnvironment(nil, scenarioName)
	if err != nil {
		return fmt.Errorf("failed to get global environment: %w", err)
	}

	// Convert form results to environment variables
	formEnv := formResult.GetEnvironmentVariables()

	// Convert to the format expected by the orchestrator
	parsedFields := make(map[string]ParsedField)
	environment := make(map[string]string)
	volumes := make(map[string]string)

	// Prepare kubeconfig automatically (like run.go does)
	kubeconfigPath, err := utils.PrepareKubeconfig(nil, config)
	if err != nil {
		return fmt.Errorf("failed to prepare kubeconfig: %w", err)
	}
	if kubeconfigPath != nil {
		volumes[*kubeconfigPath] = config.KubeconfigPath
		fmt.Printf("üîß auto-mounted kubeconfig: %s -> %s\n", *kubeconfigPath, config.KubeconfigPath)
	}

	// Process scenario fields
	for _, field := range scenarioDetail.Fields {
		if field.Variable != nil {
			if value, exists := formEnv[*field.Variable]; exists {
				if field.Type != typing.File {
					// Regular environment variable
					parsedFields[*field.Variable] = ParsedField{
						value:  value,
						secret: field.Secret,
					}
					environment[*field.Variable] = value
				} else if field.Type == typing.File {
					// File field - handle as volume mount
					if field.MountPath != nil {
						volumes[value] = *field.MountPath
						parsedFields[*field.Variable] = ParsedField{
							value:  *field.MountPath,
							secret: field.Secret,
						}
						environment[*field.Variable] = *field.MountPath
					}
				}
			}
		}
	}

	// Process global fields
	for _, field := range globalDetail.Fields {
		if field.Variable != nil {
			if value, exists := formEnv[*field.Variable]; exists {
				if field.Type != typing.File {
					// Regular environment variable
					parsedFields[*field.Variable] = ParsedField{
						value:  value,
						secret: field.Secret,
					}
					environment[*field.Variable] = value
				} else if field.Type == typing.File {
					// File field - handle as volume mount
					if field.MountPath != nil {
						volumes[value] = *field.MountPath
						parsedFields[*field.Variable] = ParsedField{
							value:  *field.MountPath,
							secret: field.Secret,
						}
						environment[*field.Variable] = *field.MountPath
					}
				}
			}
		}
	}

	// Display environment table
	fmt.Printf("\nüìã scenario configuration:\n")
	tbl := NewEnvironmentTable(parsedFields, config)
	tbl.Print()

	// Display volume mounts if any
	if len(volumes) > 0 {
		fmt.Printf("\nüìÇ volume mounts:\n")
		for hostPath, containerPath := range volumes {
			fmt.Printf("  %s -> %s\n",
				color.New(color.FgYellow).Sprint(hostPath),
				color.New(color.FgCyan).Sprint(containerPath))
		}
	}
	fmt.Print("\n")

	// Get socket connection
	socket, err := orchestrator.GetContainerRuntimeSocket(nil)
	if err != nil {
		return fmt.Errorf("failed to get container runtime socket: %w", err)
	}
	conn, err := orchestrator.Connect(*socket)
	if err != nil {
		return fmt.Errorf("failed to connect to container runtime: %w", err)
	}

	// Get scenario image URI
	quayImageURI, err := config.GetCustomDomainImageURI()
	if err != nil {
		return fmt.Errorf("failed to get image URI: %w", err)
	}
	scenarioImageURI := quayImageURI + ":" + scenarioName

	// Generate container name
	containerName := utils.GenerateContainerName(config, scenarioName, nil)

	fmt.Printf("üì¶ container image: %s\n", scenarioImageURI)
	fmt.Printf("üè∑Ô∏è  container name: %s\n", containerName)
	fmt.Printf("üéØ running in attached mode...\n\n")

	// Create spinner for image pull progress
	spinner := spinner.New(spinner.CharSets[9], 100*time.Millisecond)
	spinner.Suffix = " pulling scenario image..."
	spinner.Start()

	// Execute the scenario container in attached mode
	commChan := make(chan *string)
	go func() {
		for msg := range commChan {
			spinner.Suffix = *msg
		}
		spinner.Stop()
	}()

	startTime := time.Now()
	_, err = orchestrator.RunAttached(scenarioImageURI, containerName, environment, false, volumes, nil, os.Stdout, os.Stderr, &commChan, conn, nil)
	if err != nil {
		var staterr *utils.ExitError
		if errors.As(err, &staterr) {
			fmt.Printf("\n‚ùå scenario exited with status: %d\n", staterr.ExitStatus)
			return nil // Don't return error for non-zero exit status
		}
		return fmt.Errorf("failed to run scenario: %w", err)
	}

	scenarioDuration := time.Since(startTime)
	fmt.Printf("\n‚úÖ %s completed successfully in %s\n", scenarioName, scenarioDuration.String())

	return nil
}
