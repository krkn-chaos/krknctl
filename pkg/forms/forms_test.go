// Generated by Claude Code
// Assisted by Claude AI

package forms

import (
	"testing"

	"github.com/krkn-chaos/krknctl/pkg/typing"
	"github.com/stretchr/testify/assert"
)

// Helper function to create string pointers
func stringPtr(s string) *string {
	return &s
}

// Helper function to create test InputFields
func createTestField(name, variable string, fieldType typing.Type, required bool) typing.InputField {
	return typing.InputField{
		Name:             stringPtr(name),
		Variable:         stringPtr(variable),
		Type:             fieldType,
		Required:         required,
		ShortDescription: stringPtr("Test description for " + name),
		Description:      stringPtr("Detailed description for " + name),
	}
}

func createTestFieldWithDefault(name, variable string, fieldType typing.Type, required bool, defaultValue string) typing.InputField {
	field := createTestField(name, variable, fieldType, required)
	field.Default = stringPtr(defaultValue)
	return field
}

func createTestFieldWithSecret(name, variable string, fieldType typing.Type, required bool, secret bool) typing.InputField {
	field := createTestField(name, variable, fieldType, required)
	field.Secret = secret
	return field
}

func createTestEnumField(name, variable string, required bool, allowedValues, separator string) typing.InputField {
	field := createTestField(name, variable, typing.Enum, required)
	field.AllowedValues = stringPtr(allowedValues)
	field.Separator = stringPtr(separator)
	return field
}

func TestNewForm(t *testing.T) {
	t.Run("creates form with empty fields", func(t *testing.T) {
		fields := []typing.InputField{}
		form := NewForm(fields, nil)

		assert.NotNil(t, form)
		assert.Empty(t, form.RequiredItems)
		assert.Empty(t, form.OptionalItems)
		assert.Empty(t, form.GlobalItems)
	})

	t.Run("separates required and optional fields correctly", func(t *testing.T) {
		fields := []typing.InputField{
			createTestField("req1", "REQ1", typing.String, true),
			createTestField("opt1", "OPT1", typing.String, false),
			createTestField("req2", "REQ2", typing.Number, true),
			createTestField("opt2", "OPT2", typing.Boolean, false),
		}

		form := NewForm(fields, nil)

		assert.Len(t, form.RequiredItems, 2)
		assert.Len(t, form.OptionalItems, 2)
		assert.Empty(t, form.GlobalItems)

		// Check that required fields are correctly identified
		assert.Equal(t, "req1", *form.RequiredItems[0].Field.Name)
		assert.Equal(t, "req2", *form.RequiredItems[1].Field.Name)

		// Check that optional fields are correctly identified
		assert.Equal(t, "opt1", *form.OptionalItems[0].Field.Name)
		assert.Equal(t, "opt2", *form.OptionalItems[1].Field.Name)
	})

	t.Run("handles predefined values correctly", func(t *testing.T) {
		fields := []typing.InputField{
			createTestField("field1", "FIELD1", typing.String, true),
			createTestField("field2", "FIELD2", typing.String, false),
		}

		predefinedValues := map[string]*string{
			"FIELD1": stringPtr("predefined_value1"),
			"FIELD3": stringPtr("predefined_value3"), // This should be ignored
		}

		form := NewForm(fields, predefinedValues)

		assert.Len(t, form.RequiredItems, 1)
		assert.Len(t, form.OptionalItems, 1)

		// Check that predefined value is set for existing field
		assert.Equal(t, "predefined_value1", *form.RequiredItems[0].PredefinedValue)

		// Check that field without predefined value has nil PredefinedValue
		assert.Nil(t, form.OptionalItems[0].PredefinedValue)
	})

	t.Run("handles fields with missing required properties", func(t *testing.T) {
		// Field with missing Variable
		fieldWithoutVariable := typing.InputField{
			Name:     stringPtr("test"),
			Type:     typing.String,
			Required: true,
		}

		// Field with missing Name
		fieldWithoutName := typing.InputField{
			Variable: stringPtr("TEST"),
			Type:     typing.String,
			Required: true,
		}

		fields := []typing.InputField{fieldWithoutVariable, fieldWithoutName}
		form := NewForm(fields, nil)

		// Form should still be created, validation will happen during processing
		assert.NotNil(t, form)
		assert.Len(t, form.RequiredItems, 2)
	})
}

func TestFormResult(t *testing.T) {
	t.Run("GetValue returns correct values", func(t *testing.T) {
		result := &FormResult{
			Values: map[string]*string{
				"VAR1": stringPtr("value1"),
				"VAR2": stringPtr("value2"),
				"VAR3": nil,
			},
		}

		assert.Equal(t, "value1", *result.GetValue("VAR1"))
		assert.Equal(t, "value2", *result.GetValue("VAR2"))
		assert.Nil(t, result.GetValue("VAR3"))
		assert.Nil(t, result.GetValue("NONEXISTENT"))
	})

	t.Run("HasErrors works correctly", func(t *testing.T) {
		resultWithoutErrors := &FormResult{
			Values: map[string]*string{},
			Errors: []error{},
		}

		resultWithErrors := &FormResult{
			Values: map[string]*string{},
			Errors: []error{assert.AnError},
		}

		assert.False(t, resultWithoutErrors.HasErrors())
		assert.True(t, resultWithErrors.HasErrors())
	})

	t.Run("GetEnvironmentVariables converts correctly", func(t *testing.T) {
		result := &FormResult{
			Values: map[string]*string{
				"VAR1": stringPtr("value1"),
				"VAR2": stringPtr("value2"),
				"VAR3": nil, // Should be excluded
			},
		}

		env := result.GetEnvironmentVariables()

		assert.Len(t, env, 2)
		assert.Equal(t, "value1", env["VAR1"])
		assert.Equal(t, "value2", env["VAR2"])
		assert.NotContains(t, env, "VAR3")
	})
}

func TestFormValidation(t *testing.T) {
	t.Run("validates string fields correctly", func(t *testing.T) {
		// Test basic string validation
		field := createTestField("test", "TEST", typing.String, true)

		// Valid string should pass validation
		value := stringPtr("valid_string")
		validatedValue, err := field.Validate(value)
		assert.NoError(t, err)
		assert.Equal(t, "valid_string", *validatedValue)

		// Empty string for required field without default should fail
		field.Required = true
		field.Default = nil
		_, err = field.Validate(nil)
		assert.Error(t, err)
	})

	t.Run("validates number fields correctly", func(t *testing.T) {
		field := createTestField("number", "NUMBER", typing.Number, true)

		// Valid numbers
		validNumbers := []string{"123", "123.45", "-456", "0", "3.14159"}
		for _, num := range validNumbers {
			value := stringPtr(num)
			_, err := field.Validate(value)
			assert.NoError(t, err, "Should validate number: %s", num)
		}

		// Invalid numbers
		invalidNumbers := []string{"abc", "12.34.56", "", "12a", "a12"}
		for _, num := range invalidNumbers {
			value := stringPtr(num)
			_, err := field.Validate(value)
			assert.Error(t, err, "Should reject invalid number: %s", num)
		}
	})

	t.Run("validates boolean fields correctly", func(t *testing.T) {
		field := createTestField("bool", "BOOL", typing.Boolean, true)

		// Valid booleans
		validBooleans := []string{"true", "false", "TRUE", "FALSE", "1", "0", "t", "f", "T", "F"}
		for _, b := range validBooleans {
			value := stringPtr(b)
			_, err := field.Validate(value)
			assert.NoError(t, err, "Should validate boolean: %s", b)
		}

		// Invalid booleans
		invalidBooleans := []string{"yes", "no", "maybe", "2", "-1", ""}
		for _, b := range invalidBooleans {
			value := stringPtr(b)
			_, err := field.Validate(value)
			assert.Error(t, err, "Should reject invalid boolean: %s", b)
		}
	})

	t.Run("validates enum fields correctly", func(t *testing.T) {
		field := createTestEnumField("env", "ENV", true, "dev,staging,prod", ",")

		// Valid enum values
		validValues := []string{"dev", "staging", "prod"}
		for _, val := range validValues {
			value := stringPtr(val)
			_, err := field.Validate(value)
			assert.NoError(t, err, "Should validate enum value: %s", val)
		}

		// Invalid enum values
		invalidValues := []string{"development", "test", "", "DEV", "dev,staging"}
		for _, val := range invalidValues {
			value := stringPtr(val)
			_, err := field.Validate(value)
			assert.Error(t, err, "Should reject invalid enum value: %s", val)
		}
	})

	t.Run("validates enum with custom separator", func(t *testing.T) {
		field := createTestEnumField("level", "LEVEL", true, "low|medium|high", "|")

		validValue := stringPtr("medium")
		_, err := field.Validate(validValue)
		assert.NoError(t, err)

		invalidValue := stringPtr("extreme")
		_, err = field.Validate(invalidValue)
		assert.Error(t, err)
	})

	t.Run("handles default values correctly", func(t *testing.T) {
		field := createTestFieldWithDefault("test", "TEST", typing.String, false, "default_value")

		// Nil value should use default
		validatedValue, err := field.Validate(nil)
		assert.NoError(t, err)
		assert.Equal(t, "default_value", *validatedValue)

		// Empty string should use default for non-string types
		field.Type = typing.Number
		field.Default = stringPtr("42")
		validatedValue, err = field.Validate(stringPtr(""))
		assert.NoError(t, err)
		assert.Equal(t, "42", *validatedValue)
	})

	t.Run("validates fields with regex validator", func(t *testing.T) {
		field := createTestField("email", "EMAIL", typing.String, true)
		field.Validator = stringPtr(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)

		// Valid email
		validEmail := stringPtr("test@example.com")
		_, err := field.Validate(validEmail)
		assert.NoError(t, err)

		// Invalid email
		invalidEmail := stringPtr("invalid-email")
		_, err = field.Validate(invalidEmail)
		assert.Error(t, err)
	})

	t.Run("uses custom validation message when provided", func(t *testing.T) {
		field := createTestField("custom", "CUSTOM", typing.String, true)
		field.Validator = stringPtr(`^\d+$`)
		field.ValidationMessage = stringPtr("Please enter numbers only")

		invalidValue := stringPtr("abc123")
		_, err := field.Validate(invalidValue)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "Please enter numbers only")
	})
}

func TestFormEdgeCases(t *testing.T) {
	t.Run("handles fields with nil required properties gracefully", func(t *testing.T) {
		field := typing.InputField{
			Type:     typing.String,
			Required: true,
		}

		// Missing Name should cause validation error during processing
		assert.Nil(t, field.Name)
		assert.Nil(t, field.Variable)
	})

	t.Run("handles enum field without allowed values", func(t *testing.T) {
		field := createTestField("enum", "ENUM", typing.Enum, true)
		// AllowedValues is nil

		value := stringPtr("any_value")
		_, err := field.Validate(value)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "allowed_values")
	})

	t.Run("handles recursive default value validation", func(t *testing.T) {
		field := createTestFieldWithDefault("number", "NUMBER", typing.Number, true, "invalid_number")

		// Default value is invalid, should return schema validation error
		_, err := field.Validate(nil)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "schema validation error")
	})

	t.Run("handles file type validation", func(t *testing.T) {
		field := createTestField("file", "FILE", typing.File, true)

		// Non-existent file should fail
		nonExistentFile := stringPtr("/non/existent/file.txt")
		_, err := field.Validate(nonExistentFile)
		assert.Error(t, err)
	})

	t.Run("handles file_base64 type validation", func(t *testing.T) {
		field := createTestField("file", "FILE", typing.FileBase64, true)

		// Non-existent file should fail
		nonExistentFile := stringPtr("/non/existent/file.txt")
		_, err := field.Validate(nonExistentFile)
		assert.Error(t, err)
	})

	t.Run("handles unknown field type", func(t *testing.T) {
		field := createTestField("unknown", "UNKNOWN", typing.Unknown, true)

		value := stringPtr("any_value")
		_, err := field.Validate(value)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "impossible to validate")
	})
}

func TestFormConstruction(t *testing.T) {
	t.Run("preserves field order within required/optional categories", func(t *testing.T) {
		fields := []typing.InputField{
			createTestField("req_third", "REQ3", typing.String, true),
			createTestField("opt_first", "OPT1", typing.String, false),
			createTestField("req_first", "REQ1", typing.String, true),
			createTestField("opt_second", "OPT2", typing.String, false),
			createTestField("req_second", "REQ2", typing.String, true),
		}

		form := NewForm(fields, nil)

		// Check that required fields maintain order
		assert.Equal(t, "req_third", *form.RequiredItems[0].Field.Name)
		assert.Equal(t, "req_first", *form.RequiredItems[1].Field.Name)
		assert.Equal(t, "req_second", *form.RequiredItems[2].Field.Name)

		// Check that optional fields maintain order
		assert.Equal(t, "opt_first", *form.OptionalItems[0].Field.Name)
		assert.Equal(t, "opt_second", *form.OptionalItems[1].Field.Name)
	})

	t.Run("handles mixed field types correctly", func(t *testing.T) {
		fields := []typing.InputField{
			createTestField("string_field", "STR", typing.String, true),
			createTestField("number_field", "NUM", typing.Number, false),
			createTestFieldWithSecret("secret_field", "SECRET", typing.String, true, true),
			createTestEnumField("enum_field", "ENUM", false, "a,b,c", ","),
		}

		form := NewForm(fields, nil)

		assert.Len(t, form.RequiredItems, 2) // string_field, secret_field
		assert.Len(t, form.OptionalItems, 2) // number_field, enum_field

		// Verify types are preserved
		assert.Equal(t, typing.String, form.RequiredItems[0].Field.Type)
		assert.Equal(t, typing.String, form.RequiredItems[1].Field.Type)
		assert.Equal(t, typing.Number, form.OptionalItems[0].Field.Type)
		assert.Equal(t, typing.Enum, form.OptionalItems[1].Field.Type)

		// Verify secret flag is preserved
		assert.False(t, form.RequiredItems[0].Field.Secret)
		assert.True(t, form.RequiredItems[1].Field.Secret)
	})
}

func TestFormResultPrintSummary(t *testing.T) {
	t.Run("PrintSummary handles empty values", func(t *testing.T) {
		result := &FormResult{
			Values: map[string]*string{},
		}

		fields := []typing.InputField{}

		// Should not panic with empty values
		assert.NotPanics(t, func() {
			result.PrintSummary(fields)
		})
	})

	t.Run("PrintSummary handles fields without matching variables", func(t *testing.T) {
		result := &FormResult{
			Values: map[string]*string{
				"UNKNOWN_VAR": stringPtr("value"),
			},
		}

		fields := []typing.InputField{
			createTestField("known", "KNOWN_VAR", typing.String, true),
		}

		// Should not panic when result contains variables not in fields
		assert.NotPanics(t, func() {
			result.PrintSummary(fields)
		})
	})

	t.Run("PrintSummary handles nil values in result", func(t *testing.T) {
		result := &FormResult{
			Values: map[string]*string{
				"VAR1": stringPtr("value1"),
				"VAR2": nil,
			},
		}

		fields := []typing.InputField{
			createTestField("field1", "VAR1", typing.String, true),
			createTestField("field2", "VAR2", typing.String, false),
		}

		// Should not panic with nil values
		assert.NotPanics(t, func() {
			result.PrintSummary(fields)
		})
	})
}