// Generated by Claude Code
// Assisted by Claude AI

// Package forms provides interactive CLI form functionality for collecting user input
package forms

import (
	"fmt"
	"strings"

	"github.com/fatih/color"
	"github.com/krkn-chaos/krknctl/pkg/typing"
	"github.com/manifoldco/promptui"
)

// FormPromptItem represents a single form input item with optional predefined value
type FormPromptItem struct {
	Field          *typing.InputField
	PredefinedValue *string
}

// FormResult represents the collected values from the form
// Values maps InputField.Variable (environment variable name) to validated value
type FormResult struct {
	Values map[string]*string // Variable name (env var) -> validated value
	Errors []error            // Any validation errors that occurred
}

// Form represents a collection of form prompt items
type Form struct {
	RequiredItems []FormPromptItem
	OptionalItems []FormPromptItem
	GlobalItems   []FormPromptItem  // Global values array
}

// NewForm creates a new form from a slice of InputFields and optional predefined values
func NewForm(fields []typing.InputField, predefinedValues map[string]*string) *Form {
	form := &Form{
		RequiredItems: make([]FormPromptItem, 0),
		OptionalItems: make([]FormPromptItem, 0),
		GlobalItems:   make([]FormPromptItem, 0),
	}

	for _, field := range fields {
		var predefinedValue *string
		if predefinedValues != nil && field.Variable != nil {
			if val, exists := predefinedValues[*field.Variable]; exists {
				predefinedValue = val
			}
		}

		item := FormPromptItem{
			Field:           &field,
			PredefinedValue: predefinedValue,
		}

		if field.Required {
			form.RequiredItems = append(form.RequiredItems, item)
		} else {
			form.OptionalItems = append(form.OptionalItems, item)
		}
	}

	return form
}

// Run executes the form, collecting input from the user
func (f *Form) Run() (*FormResult, error) {
	result := &FormResult{
		Values: make(map[string]*string),
		Errors: make([]error, 0),
	}

	// Process required fields first
	if len(f.RequiredItems) > 0 {
		fmt.Printf("\n%s\n", color.New(color.FgGreen, color.Bold).Sprint("üî¥ Required Fields"))
		for _, item := range f.RequiredItems {
			if err := f.processItem(item, result); err != nil {
				return result, err
			}
		}
	}

	// Ask if user wants to set optional fields
	if len(f.OptionalItems) > 0 {
		askOptional := promptui.Prompt{
			Label:     "Do you want to set non mandatory fields?",
			IsConfirm: true,
			Default:   "n",
		}

		if _, err := askOptional.Run(); err == nil {
			fmt.Printf("\n%s\n", color.New(color.FgYellow, color.Bold).Sprint("üü° Optional Fields"))
			for _, item := range f.OptionalItems {
				if err := f.processItem(item, result); err != nil {
					return result, err
				}
			}
		}
	}

	// Ask if user wants to set global fields
	if len(f.GlobalItems) > 0 {
		askGlobal := promptui.Prompt{
			Label:     "Do you want to set global values?",
			IsConfirm: true,
			Default:   "n",
		}

		if _, err := askGlobal.Run(); err == nil {
			fmt.Printf("\n%s\n", color.New(color.FgBlue, color.Bold).Sprint("üåê Global Values"))
			for _, item := range f.GlobalItems {
				if err := f.processItem(item, result); err != nil {
					return result, err
				}
			}
		}
	}

	return result, nil
}

// processItem handles the input collection and validation for a single form item
func (f *Form) processItem(item FormPromptItem, result *FormResult) error {
	field := item.Field
	if field.Variable == nil || field.Name == nil {
		return fmt.Errorf("invalid field configuration: missing variable or name")
	}

	// Determine the default value to display
	var defaultValue string
	var hasDefault bool

	if item.PredefinedValue != nil {
		defaultValue = *item.PredefinedValue
		hasDefault = true
	} else if field.Default != nil {
		defaultValue = *field.Default
		hasDefault = true
	}

	// Build the prompt label
	label := fmt.Sprintf("%s (%s)", *field.Name, field.Type.String())
	if field.ShortDescription != nil && *field.ShortDescription != "" {
		label = fmt.Sprintf("%s - %s", label, *field.ShortDescription)
	}

	// Validation loop
	for {
		var prompt promptui.Prompt

		if hasDefault {
			// Show default value in brackets
			prompt = promptui.Prompt{
				Label:   fmt.Sprintf("%s [%s]", label, defaultValue),
				Default: defaultValue,
			}
		} else {
			prompt = promptui.Prompt{
				Label: label,
			}
		}

		// Special handling for sensitive fields
		if field.Secret {
			prompt.Mask = '*'
		}

		// Special handling for enum fields - show allowed values
		if field.Type == typing.Enum && field.AllowedValues != nil {
			separator := ","
			if field.Separator != nil {
				separator = *field.Separator
			}
			values := strings.Split(*field.AllowedValues, separator)
			prompt.Label = fmt.Sprintf("%s (allowed: %s)", prompt.Label, strings.Join(values, ", "))
		}

		input, err := prompt.Run()
		if err != nil {
			return fmt.Errorf("failed to read input: %w", err)
		}

		// If input is empty and we have a default, use the default
		var valueToValidate *string
		if strings.TrimSpace(input) == "" && hasDefault {
			valueToValidate = &defaultValue
		} else if strings.TrimSpace(input) != "" {
			trimmed := strings.TrimSpace(input)
			valueToValidate = &trimmed
		} else {
			valueToValidate = nil
		}

		// Validate the value
		validatedValue, err := field.Validate(valueToValidate)
		if err != nil {
			// Show validation error in red and ask again
			fmt.Printf("%s %v\n", color.New(color.FgRed).Sprint("‚ùå Validation error:"), err)
			continue
		}

		// Store the validated value using Variable (environment variable name) as key
		result.Values[*field.Variable] = validatedValue
		break
	}

	return nil
}

// PrintSummary prints a summary of the collected form values
func (r *FormResult) PrintSummary(fields []typing.InputField) {
	if len(r.Values) == 0 {
		fmt.Println("No values collected.")
		return
	}

	fmt.Printf("\n%s\n", color.New(color.FgCyan, color.Bold, color.Underline).Sprint("üìã Form Summary"))

	// Create a map for quick field lookup by Variable name
	fieldMap := make(map[string]*typing.InputField)
	for _, field := range fields {
		if field.Variable != nil {
			fieldMap[*field.Variable] = &field
		}
	}

	for variable, value := range r.Values {
		field, exists := fieldMap[variable]
		var displayName string
		if exists && field.Name != nil {
			displayName = *field.Name
		} else {
			displayName = variable
		}

		var displayValue string
		if value == nil {
			displayValue = color.New(color.FgHiBlack).Sprint("<nil>")
		} else if exists && field.Secret {
			displayValue = color.New(color.FgHiBlack).Sprint("***")
		} else {
			displayValue = *value
		}

		fmt.Printf("  %s: %s\n",
			color.New(color.FgYellow).Sprint(displayName),
			displayValue)
	}
	fmt.Println()
}

// GetValue retrieves a validated value by variable name (environment variable name)
func (r *FormResult) GetValue(variable string) *string {
	return r.Values[variable]
}

// HasErrors returns true if the form collection encountered any errors
func (r *FormResult) HasErrors() bool {
	return len(r.Errors) > 0
}

// GetEnvironmentVariables returns the form result values as environment variables
// ready to be used for container initialization
func (r *FormResult) GetEnvironmentVariables() map[string]string {
	env := make(map[string]string)
	for variable, value := range r.Values {
		if value != nil {
			env[variable] = *value
		}
	}
	return env
}