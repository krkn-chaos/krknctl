// Generated by Claude Code
// RAG model deployment functions for krknctl lightspeed

package lightspeed

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/briandowns/spinner"
	"github.com/fatih/color"
	"github.com/krkn-chaos/krknctl/pkg/config"
	"github.com/krkn-chaos/krknctl/pkg/provider"
	"github.com/krkn-chaos/krknctl/pkg/provider/models"
	"github.com/krkn-chaos/krknctl/pkg/scenarioorchestrator"
	"github.com/krkn-chaos/krknctl/pkg/text"
	"github.com/krkn-chaos/krknctl/pkg/typing"
	"github.com/rodaine/table"
)

// DeployLightspeedModelWithGPUType deploys the RAG model container using the new GPU detection system
func DeployLightspeedModelWithGPUType(ctx context.Context, gpuType GPUAcceleration, orchestrator scenarioorchestrator.ScenarioOrchestrator, config config.Config, registry *models.RegistryV2, detector GPUDetector, pullSpinner *spinner.Spinner) (*RAGDeploymentResult, error) {
	// Get the appropriate lightspeed image for the detected GPU type
	ragImageURI, err := detector.GetLightspeedImageURI(gpuType)
	if err != nil {
		return nil, fmt.Errorf("failed to get lightspeed image URI: %w", err)
	}

	// Generate unique container name using config
	containerName := fmt.Sprintf("%s-%d", config.RAGContainerPrefix, time.Now().Unix())

	// Set up environment variables
	env := map[string]string{}

	// Add GPU-specific environment variables for optimal performance
	switch gpuType {
	case GPUAccelerationNVIDIA:
		env["CUDA_VISIBLE_DEVICES"] = "0"
		env["TORCH_USE_CUDA_DSA"] = "1"
		env["PYTORCH_CUDA_ALLOC_CONF"] = "max_split_size_mb:128"
	case GPUAccelerationAppleSilicon:
		env["PYTORCH_ENABLE_MPS_FALLBACK"] = "1"
		env["PYTORCH_MPS_HIGH_WATERMARK_RATIO"] = "0.0"
	case GPUAccelerationGeneric:
		env["OMP_NUM_THREADS"] = "4"
		env["MKL_NUM_THREADS"] = "4"
	}

	// Get device mounts from detector
	devices := detector.GetDeviceMounts(gpuType)

	// Set up port mapping using config
	hostPort := config.RAGServicePort      // Host port (e.g., "8080")
	containerPort := config.RAGServicePort // Container port (e.g., "8080")
	portMappings := &map[string]string{
		hostPort: containerPort, // host port -> container port
	}

	// Use provided spinner for pull progress
	if pullSpinner != nil {
		pullSpinner.Suffix = " pulling RAG model image..."
		pullSpinner.Start()
	}

	// Create communication channel for pull progress updates
	commChan := make(chan *string)
	go func() {
		for msg := range commChan {
			if pullSpinner != nil {
				pullSpinner.Suffix = *msg
			}
		}
		if pullSpinner != nil {
			pullSpinner.Stop()
		}
	}()

	// Run the RAG container in detached mode
	containerID, err := orchestrator.Run(ragImageURI, containerName, env, false, nil, &devices,
		&commChan, ctx, registry, portMappings)

	// The orchestrator closes the channel automatically, so we don't need to close it manually
	if err != nil {
		return nil, fmt.Errorf("failed to run RAG container: %w", err)
	}
	fmt.Printf("üöÄ RAG container started: %s\n", *containerID)
	fmt.Printf("üì° Port mapping: %s:%s -> container:%s\n", config.RAGHost, hostPort, config.RAGServicePort)

	return &RAGDeploymentResult{
		ContainerID: *containerID,
		HostPort:    hostPort,
	}, nil
}

// PerformLightspeedHealthCheck performs health checking with timeout and cleanup on failure
func PerformLightspeedHealthCheck(containerID string, hostPort string, orchestrator scenarioorchestrator.ScenarioOrchestrator, ctx context.Context, config config.Config) (bool, error) {
	// Health URL is constructed from trusted config values and validated port
	healthURL := fmt.Sprintf("http://%s:%s%s", config.RAGHost, hostPort, config.RAGHealthEndpoint)
	maxRetries := config.RAGHealthMaxRetries
	retryInterval := time.Duration(config.RAGHealthRetryIntervalSeconds) * time.Second

	fmt.Printf("ü©∫ Health checking Lightspeed service at %s...\n", healthURL)

	for i := 0; i < maxRetries; i++ {
		// Check if container is still running
		containers, err := orchestrator.ListRunningContainers(ctx)
		if err != nil {
			fmt.Printf("‚ö†Ô∏è  Warning: failed to list containers: %v\n", err)
		} else {
			containerFound := false
			if containers != nil {
				for _, container := range *containers {
					if container.ID == containerID {
						containerFound = true
						break
					}
				}
			}
			if !containerFound {
				return false, fmt.Errorf("container %s is no longer running", containerID)
			}
		}

		// Perform health check - URL is safe as it's constructed from config
		// #nosec G107 - URL constructed from trusted configuration
		resp, err := http.Get(healthURL)
		if err == nil && resp.StatusCode == 200 {
			var health HealthResponse
			if err := json.NewDecoder(resp.Body).Decode(&health); err == nil {
				if closeErr := resp.Body.Close(); closeErr != nil {
					fmt.Printf("‚ö†Ô∏è  Warning: failed to close response body: %v\n", closeErr)
				}
				if health.Status == "healthy" {
					fmt.Printf("‚úÖ Service healthy: %s with %d documents indexed\n", health.Model, health.DocumentsIndexed)
					return true, nil
				}
			}
			if closeErr := resp.Body.Close(); closeErr != nil {
				fmt.Printf("‚ö†Ô∏è  Warning: failed to close response body: %v\n", closeErr)
			}
		}

		if i < maxRetries-1 {
			fmt.Printf("‚è≥ Waiting for service to become ready... (%d/%d)\n", i+1, maxRetries)
			time.Sleep(retryInterval)
		}
	}

	// Health check failed, clean up the container
	timeoutMinutes := (maxRetries * config.RAGHealthRetryIntervalSeconds) / 60
	fmt.Printf("‚ùå Health check timed out after %d minutes, cleaning up container...\n", timeoutMinutes)
	if err := orchestrator.Kill(&containerID, ctx); err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: failed to clean up container %s: %v\n", containerID, err)
	}

	return false, fmt.Errorf("service did not become healthy within timeout")
}

// StartInteractivePrompt starts an interactive chat session with the Lightspeed service
func StartInteractivePrompt(containerID string, hostPort string, orchestrator scenarioorchestrator.ScenarioOrchestrator, ctx context.Context, config config.Config, thinkingSpinner *spinner.Spinner, scenarioProvider provider.ScenarioDataProvider) error {
	scanner := bufio.NewScanner(os.Stdin)

	// Set up signal handling for Ctrl+C
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM)

	// Handle Ctrl+C in a goroutine
	go func() {
		<-signalChan
		fmt.Println("\n\nüõë Interrupted! Cleaning up Lightspeed service...")
		if err := orchestrator.Kill(&containerID, ctx); err != nil {
			fmt.Printf("‚ö†Ô∏è  Warning: failed to stop Lightspeed container: %v\n", err)
		} else {
			fmt.Println("‚úÖ Lightspeed service stopped successfully")
		}
		os.Exit(0)
	}()

	fmt.Printf("ü§ñ AI Assistant ready! Ask me about krknctl commands or chaos engineering:\n")
	fmt.Printf("üìç Service available at: http://%s:%s\n", config.RAGHost, hostPort)
	fmt.Printf("üí° Try asking: 'How do I run a pod deletion scenario?'\n")
	fmt.Printf("üö™ Type 'exit', 'quit', or press Ctrl+C to stop.\n\n")

	for {
		fmt.Print("> ")
		if !scanner.Scan() {
			break
		}

		query := strings.TrimSpace(scanner.Text())
		if query == "" {
			continue
		}

		if strings.ToLower(query) == "exit" || strings.ToLower(query) == "quit" {
			fmt.Println("üëã Goodbye!")
			break
		}

		// Send query to Lightspeed service with spinner
		if thinkingSpinner != nil {
			thinkingSpinner.Suffix = " thinking..."
			thinkingSpinner.Start()
		}
		response, err := queryLightspeedService(hostPort, query, config)
		if thinkingSpinner != nil {
			thinkingSpinner.Stop()
		}

		if err != nil {
			fmt.Printf("‚ùå Error: %v\n", err)
			fmt.Printf("üí° Tip: Make sure the service is fully initialized. Large models may take a few minutes.\n")
			continue
		}

		// Display response
		if len(response.Choices) > 0 {
			fmt.Printf("\nü§ñ %s\n", response.Choices[0].Message.Content)
		} else {
			fmt.Printf("\nü§ñ No response received\n")
		}

		// If a scenario was detected, show scenario details
		if response.ScenarioName != nil && *response.ScenarioName != "" {
			fmt.Printf("\nüìã Fetching details for scenario: %s\n", *response.ScenarioName)

			scenarioDetail, err := scenarioProvider.GetScenarioDetail(*response.ScenarioName, nil)
			if err != nil {
				fmt.Printf("‚ö†Ô∏è  Could not fetch scenario details: %v\n", err)
			} else if scenarioDetail != nil {
				printScenarioDetail(scenarioDetail)
			}
		}

		fmt.Println()
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading input: %w", err)
	}

	// Clean up: stop the container
	fmt.Println("\nüßπ Cleaning up Lightspeed service...")
	if err := orchestrator.Kill(&containerID, ctx); err != nil {
		fmt.Printf("‚ö†Ô∏è  Warning: failed to stop Lightspeed container: %v\n", err)
	} else {
		fmt.Println("‚úÖ Lightspeed service stopped successfully")
	}

	return nil
}

// queryLightspeedService sends a query to the Lightspeed service and returns the response
func queryLightspeedService(hostPort string, query string, config config.Config) (*QueryResponse, error) {
	// Query URL is constructed from trusted config values and validated port
	url := fmt.Sprintf("http://%s:%s%s", config.RAGHost, hostPort, config.RAGQueryEndpoint)

	requestBody := QueryRequest{
		Model: "llama",
		Messages: []ChatMessage{
			{
				Role:    "user",
				Content: query,
			},
		},
		Temperature: 0.7,
		MaxTokens:   512,
		Stream:      false,
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// #nosec G107 - URL constructed from trusted configuration
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("service returned error %d: %s", resp.StatusCode, string(body))
	}

	var response QueryResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &response, nil
}

// printScenarioDetail prints scenario details in the same format as cmd/describe.go
func printScenarioDetail(scenarioDetail *models.ScenarioDetail) {
	fmt.Print("\n")
	_, _ = color.New(color.FgGreen, color.Underline).Println(scenarioDetail.Title)
	justifiedText := text.Justify(scenarioDetail.Description, 65)
	for _, line := range justifiedText {
		fmt.Println(line)
	}
	fmt.Print("\n")
	argumentTable := newArgumentTable(scenarioDetail.Fields)
	argumentTable.Print()
	fmt.Print("\n")
}

// newArgumentTable creates argument table in same style as cmd/tables.go
func newArgumentTable(inputFields []typing.InputField) table.Table {
	var headerFmt = color.New(color.FgGreen, color.Underline).SprintfFunc()
	var columnFmt = color.New(color.FgYellow).SprintfFunc()

	tbl := table.New("Name", "Type", "Description", "Required", "Default")
	tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(columnFmt)
	for _, inputField := range inputFields {
		defaultValue := ""
		if inputField.Default != nil {
			defaultValue = *inputField.Default
		}
		tbl.AddRow(fmt.Sprintf("--%s", *inputField.Name), inputField.Type.String(), *inputField.ShortDescription, inputField.Required, defaultValue)
	}
	return tbl
}
