// Generated by Claude Sonnet 4
package config

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLoadConfig(t *testing.T) {
	config, err := LoadConfig()
	
	assert.NoError(t, err)
	assert.NotNil(t, config)
	
	// Test that basic required fields are present
	assert.NotEmpty(t, config.Version)
	assert.NotEmpty(t, config.QuayHost)
	assert.NotEmpty(t, config.QuayOrg)
	assert.NotEmpty(t, config.QuayScenarioRegistry)
	assert.NotEmpty(t, config.QuayBaseImageRegistry)
	assert.NotEmpty(t, config.QuayBaseImageTag)
	
	// Test GPU check specific fields that were added
	assert.NotEmpty(t, config.LightspeedRegistry)
	assert.NotEmpty(t, config.GpuCheckBaseTag)
	assert.Equal(t, "krknctl-lightspeed", config.LightspeedRegistry)
	assert.Equal(t, "gpu-check", config.GpuCheckBaseTag)
}

func TestGetQuayImageURI(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	uri, err := config.GetQuayImageURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, uri)
	
	// Should contain the host, org, and scenario registry
	assert.Contains(t, uri, config.QuayHost)
	assert.Contains(t, uri, config.QuayOrg)
	assert.Contains(t, uri, config.QuayScenarioRegistry)
	
	// Should be in the format: host/org/registry
	expected := config.QuayHost + "/" + config.QuayOrg + "/" + config.QuayScenarioRegistry
	assert.Equal(t, expected, uri)
}

func TestGetCustomDomainImageURI(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	uri, err := config.GetCustomDomainImageURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, uri)
	
	// Should contain the custom domain host, org, and scenario registry
	assert.Contains(t, uri, config.CustomDomainHost)
	assert.Contains(t, uri, config.QuayOrg)
	assert.Contains(t, uri, config.QuayScenarioRegistry)
	
	// Should be in the format: custom_host/org/registry
	expected := config.CustomDomainHost + "/" + config.QuayOrg + "/" + config.QuayScenarioRegistry
	assert.Equal(t, expected, uri)
}

func TestGetQuayScenarioRepositoryAPIURI(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	uri, err := config.GetQuayScenarioRepositoryAPIURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, uri)
	
	// Should be a valid HTTPS URL
	assert.Contains(t, uri, "https://")
	assert.Contains(t, uri, config.QuayHost)
	assert.Contains(t, uri, config.QuayRepositoryAPI)
	assert.Contains(t, uri, config.QuayOrg)
	assert.Contains(t, uri, config.QuayScenarioRegistry)
}

func TestGetQuayBaseImageRepositoryAPIURI(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	uri, err := config.GetQuayBaseImageRepositoryAPIURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, uri)
	
	// Should be a valid HTTPS URL
	assert.Contains(t, uri, "https://")
	assert.Contains(t, uri, config.QuayHost)
	assert.Contains(t, uri, config.QuayRepositoryAPI)
	assert.Contains(t, uri, config.QuayOrg)
	assert.Contains(t, uri, config.QuayBaseImageRegistry)
}

func TestGetGpuCheckImageURI(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	uri, err := config.GetGpuCheckImageURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, uri)
	
	// Should contain the host, org, and GPU check registry
	assert.Contains(t, uri, config.QuayHost)
	assert.Contains(t, uri, config.QuayOrg)
	assert.Contains(t, uri, config.LightspeedRegistry)
	assert.Contains(t, uri, config.GpuCheckBaseTag)
	
	// Should be in the format: host/org/registry:tag
	expected := config.QuayHost + "/" + config.QuayOrg + "/" + config.LightspeedRegistry + ":" + config.GpuCheckBaseTag
	assert.Equal(t, expected, uri)
	
	// Verify it matches the expected default image
	assert.Equal(t, "quay.io/krkn-chaos/krknctl-lightspeed:gpu-check", uri)
}

func TestConfigStructFields(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Test that all GPU check related fields are properly loaded
	assert.IsType(t, "", config.LightspeedRegistry)
	assert.IsType(t, "", config.GpuCheckBaseTag)
	
	// Test that the values are correct
	assert.Equal(t, "krknctl-lightspeed", config.LightspeedRegistry)
	assert.Equal(t, "gpu-check", config.GpuCheckBaseTag)
	
	// Test that other existing fields are still working
	assert.Equal(t, "quay.io", config.QuayHost)
	assert.Equal(t, "krkn-chaos", config.QuayOrg)
	assert.Equal(t, "krkn-hub", config.QuayScenarioRegistry)
	assert.Equal(t, "krkn", config.QuayBaseImageRegistry)
	assert.Equal(t, "latest", config.QuayBaseImageTag)
}

func TestConfigJSONStructure(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Test integer fields
	assert.IsType(t, 0, config.TableFieldMaxLength)
	assert.IsType(t, 0, config.TableMaxStepScenarioLength)
	assert.Greater(t, config.TableFieldMaxLength, 0)
	assert.Greater(t, config.TableMaxStepScenarioLength, 0)
	
	// Test string fields that should not be empty
	requiredStringFields := []string{
		config.Version,
		config.QuayHost,
		config.QuayOrg,
		config.QuayScenarioRegistry,
		config.QuayBaseImageRegistry,
		config.QuayBaseImageTag,
		config.QuayRepositoryAPI,
		config.CustomDomainHost,
		config.PrivateRegistryBaseImageTag,
		config.ContainerPrefix,
		config.KubeconfigPrefix,
		config.PodmanDarwinSocketTemplate,
		config.PodmanLinuxSocketTemplate,
		config.PodmanSocketRoot,
		config.PodmanRunningState,
		config.DockerSocketRoot,
		config.DockerRunningState,
		config.DefaultContainerPlatform,
		config.LightspeedRegistry,
		config.GpuCheckBaseTag,
	}
	
	for _, field := range requiredStringFields {
		assert.NotEmpty(t, field, "Required string field should not be empty")
	}
}

func TestConfigEnvironmentVariableFields(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Test that environment variable field names are correct
	envFields := map[string]string{
		config.EnvPrivateRegistry:          "KRKNCTL_PRIVATE_REGISTRY",
		config.EnvPrivateRegistryUsername:  "KRKNCTL_PRIVATE_REGISTRY_USERNAME",
		config.EnvPrivateRegistryPassword:  "KRKNCTL_PRIVATE_REGISTRY_PASSWORD",
		config.EnvPrivateRegistrySkipTLS:   "KRKNCTL_PRIVATE_REGISTRY_SKIP_TLS",
		config.EnvPrivateRegistryToken:     "KRKNCTL_PRIVATE_REGISTRY_TOKEN",
		config.EnvPrivateRegistryScenarios: "KRKNCTL_PRIVATE_REGISTRY_SCENARIOS",
		config.EnvPrivateRegistryInsecure:  "KRKNCTL_PRIVATE_REGISTRY_INSECURE",
	}
	
	for actual, expected := range envFields {
		assert.Equal(t, expected, actual, "Environment variable name should match expected value")
	}
}

func TestConfigGithubFields(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Test GitHub related URLs
	assert.Contains(t, config.GithubLatestRelease, "github.com")
	assert.Contains(t, config.GithubLatestRelease, "releases/latest")
	assert.Contains(t, config.GithubLatestReleaseAPI, "api.github.com")
	assert.Contains(t, config.GithubReleaseAPI, "api.github.com")
	
	// Test that URLs are properly formatted
	assert.True(t, strings.HasPrefix(config.GithubLatestRelease, "https://"))
	assert.True(t, strings.HasPrefix(config.GithubLatestReleaseAPI, "https://"))
	assert.True(t, strings.HasPrefix(config.GithubReleaseAPI, "https://"))
}

func TestConfigLabelFields(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Test that label fields contain expected prefixes
	labelFields := []string{
		config.LabelTitle,
		config.LabelDescription,
		config.LabelInputFields,
		config.LabelTitleGlobal,
		config.LabelDescriptionGlobal,
		config.LabelInputFieldsGlobal,
	}
	
	for _, field := range labelFields {
		assert.Contains(t, field, "krknctl", "Label field should contain krknctl prefix")
	}
	
	// Test regex fields contain proper regex patterns
	regexFields := []string{
		config.LabelTitleRegex,
		config.LabelDescriptionRegex,
		config.LabelInputFieldsRegex,
		config.LabelTitleRegexGlobal,
		config.LabelDescriptionRegexGlobal,
		config.LabelInputFieldsRegexGlobal,
	}
	
	for _, field := range regexFields {
		assert.Contains(t, field, "LABEL", "Regex field should contain LABEL")
		assert.Contains(t, field, "krknctl", "Regex field should contain krknctl")
	}
}

// Test error handling for invalid JSON (this would require mocking the embedded file)
func TestConfigTypes(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Verify field types are correct
	assert.IsType(t, "", config.LightspeedRegistry)
	assert.IsType(t, "", config.GpuCheckBaseTag)
	assert.IsType(t, "", config.Version)
	assert.IsType(t, "", config.QuayHost)
	assert.IsType(t, "", config.QuayOrg)
	assert.IsType(t, 0, config.TableFieldMaxLength)
	assert.IsType(t, 0, config.TableMaxStepScenarioLength)
}

// Test the GPU check image URI construction by type
func TestGetGpuCheckImageURIByType(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	tests := []struct {
		name        string
		gpuType     string
		expectedTag string
	}{
		{
			name:        "NVIDIA GPU image",
			gpuType:     "nvidia",
			expectedTag: "gpu-check-nvidia",
		},
		{
			name:        "AMD GPU image",
			gpuType:     "amd",
			expectedTag: "gpu-check-amd",
		},
		{
			name:        "Intel GPU image", 
			gpuType:     "intel",
			expectedTag: "gpu-check-intel",
		},
		{
			name:        "Apple Silicon GPU image",
			gpuType:     "apple-silicon",
			expectedTag: "gpu-check-apple-silicon",
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			uri, err := config.GetGpuCheckImageURIByType(tt.gpuType)
			
			assert.NoError(t, err)
			assert.Contains(t, uri, "quay.io/krkn-chaos/krknctl-lightspeed")
			assert.Contains(t, uri, tt.expectedTag)
			
			// Should be in the format: host/org/registry:tag
			expected := config.QuayHost + "/" + config.QuayOrg + "/" + config.LightspeedRegistry + ":" + tt.expectedTag
			assert.Equal(t, expected, uri)
		})
	}
}

// Test fallback to default image for unknown GPU type
func TestGetGpuCheckImageURIByType_Fallback(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	uri, err := config.GetGpuCheckImageURIByType("unknown-gpu-type")
	
	assert.NoError(t, err)
	assert.Contains(t, uri, "quay.io/krkn-chaos/krknctl-lightspeed")
	assert.Contains(t, uri, "gpu-check") // Should fallback to base tag
	
	// Should match the base GPU check image URI
	baseURI, baseErr := config.GetGpuCheckImageURI()
	assert.NoError(t, baseErr)
	assert.Equal(t, baseURI, uri)
}

// Test the GPU check image URI construction edge cases
func TestGetGpuCheckImageURI_EdgeCases(t *testing.T) {
	// Test with a config that has different values
	testConfig := Config{
		QuayHost:         "custom-registry.com",
		QuayOrg:          "test-org",
		LightspeedRegistry: "custom-lightspeed",
		GpuCheckBaseTag:  "v1.0.0",
	}
	
	uri, err := testConfig.GetGpuCheckImageURI()
	assert.NoError(t, err)
	assert.Equal(t, "custom-registry.com/test-org/custom-lightspeed:v1.0.0", uri)
	
	// Test the by-type method with custom config
	uriByType, err := testConfig.GetGpuCheckImageURIByType("nvidia")
	assert.NoError(t, err)
	assert.Equal(t, "custom-registry.com/test-org/custom-lightspeed:v1.0.0-nvidia", uriByType)
}

// Test that the config loading preserves all existing functionality
func TestConfigBackwardCompatibility(t *testing.T) {
	config, err := LoadConfig()
	assert.NoError(t, err)
	
	// Test that all existing URI methods still work
	quayURI, err := config.GetQuayImageURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, quayURI)
	
	customURI, err := config.GetCustomDomainImageURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, customURI)
	
	scenarioAPI, err := config.GetQuayScenarioRepositoryAPIURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, scenarioAPI)
	
	baseImageAPI, err := config.GetQuayBaseImageRepositoryAPIURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, baseImageAPI)
	
	// Test the new GPU check URI method
	gpuURI, err := config.GetGpuCheckImageURI()
	assert.NoError(t, err)
	assert.NotEmpty(t, gpuURI)
}